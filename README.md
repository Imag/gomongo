# gomongo
A handy wrapper for working with the standard mongo-go-driver. This package lets you avoid a lot of the `bson.M`s and the `bson.D`s and 
all the other fun things about working with a language that doesn't deal with JSON natively. The package is divided up into several 
different packages:
1. Database - Contains the `BaseRepository`
2. Aggregate - Contains a `Pipe` function and all the operators to construct MongoDB aggregate pipelines without dealing with `bson` types.
3. Condition - Contains a `Pipe` function and all the operators to construct a MongoDB query without dealing with `bson` types. 
4. Util - Contains handy functions like printing an interface to json to verify that your pipelines and queries look the way they should.

---
### Repositories
A repository represents a collection of methods that are called and executed on a specific collection, in other words you'll always 
have one repository per collection. The BaseRepository has a bunch of standard helper methods and is used by embedding it into our own 
custom repositories. 

For example, lets say we want to create a repository that interacts with the `user` collection. We'd start by defining a 
`UserRepository` like this:

```go
type UserRepository struct {
    CollectionName string
    *database.BaseRepository
}
```

We'll then make a method to connect our UserRepository to our MongoDB client:

```go
func NewUserRepository(client *mongo.Client) *UserRepository {
	r, err := database.NewBaseRepository(client, <DATABASE_NAME>, "user")
	if err != nil {
		log.Fatalf("initializing base repository: %v", err)
	}
	return &UserRepository{
		BaseRepository: r,
	}
}
```

All of the methods in the `BaseRepository` are available to any custom repository, some of these methods are:
* __Find__ - Takes a query and an interface and decodes the response into the interface
* __FindCursor__ - Takes a query and returns the results in the form of a `*mongo.Cursor`
* __FindOne__ - Takes a query and an interface and decodes the first matching response into the interface
* __FindById__ - Takes a string `_id` and decodes the first matching response into the interface
* __FindByIdList__ - Takes a list of string `_id` and an interface and decodes the response into the interface
* __FindDistinct__ - Takes a `fieldName`, a query and an interface and decodes the distinct values for the provided `fieldName` into the interface
* __Aggregate__ - Takes a pipeline and an `allowDiskUse` `bool` and returns a `*mongo.Cursor`
* __Create__ - Takes a document of type `Document` (interface) and inserts it into the repositories collection with an 
autogenerated `_id`, `createdDate` and `modifiedDate`
* __CreateMany__ - Does the same as above but accepts a slice of type `Document`
* __Update__ - Take a `filter` (query) and an update document (see https://docs.mongodb.com/manual/reference/operator/update/#id1) 
and a `multi` bool. If `multi` is `true` then it will update all documents matching the `filter`, otherwise it will update the 
first document to match the filter
* __UpdateById__ - Takes a string `_id`, and update document, an `autoSet` `bool` and a `[]DocStatus`. If you're using 
the operators defined here (see https://docs.mongodb.com/manual/reference/operator/update/#id1), then you can set `autoSet`
to `false`, otherwise it will automatically take your update document and wrap it inside a MongoDB `$set` operator (NOTE: when
doing any update, make sure to update the `modifiedDate` yourself). `[]DocStatus` Has two options, `Active` = 1 or `Inactive` = 0
that you can use to filter (filters on the document `status` field). Document statuses provide an alternative method for 'deleting' 
documents.
* __UpdateByIdList__ - Does the same as above but accepts a list of string `_id` to perform the update operation on
* __DeleteById__ - Takes a string `_id` and deletes the document. This is discouraged, instead use the __UpdateById__ method and 
set the status to `0`.

#### Extending the BaseRepository Functionality
The default functionality could be extended and simplified using our previous example of a `UserRepository`. `FindById` 
decodes the response into a cursor but it can be extended like this in the `UserRepository`:

```go
func (r *UserRepository) FindUserById(ctx context.Context, id string) (*User, error) {
	user := User{}
	err := r.FindById(ctx, id, &user)
	if err != nil {
		return nil, fmt.Errorf("running FindUserById: %v", err)

	}
	return &user, nil
}
```

In this case the decoding into a struct is handled in a repository and calling this method returns the user that was found:

```go
user, err := FindUserById(ctx, "5c7836b73a8de34c78fec399")
```

### Store
Store functionality is not included in this package yet but can be implemented easily. A store allows you to share a 
single MongoDB client between multiple repositories.

```go
type Store struct {
	Client                     *mongo.Client
	UserRepository             *UserRepository
}
```

Add a `NewStore` method to initilize a store with a `mongo.Client`:

```go
func NewStore(ctx context.Context, uri string) (*Store, error) {
	// create a new MongoDB client
	client, err := mongo.NewClient(options.Client().ApplyURI(uri))
	if err != nil {
		return nil, fmt.Errorf("creating mongodb client: %v", err)
	}

	// connect to MongoDB client
	err = client.Connect(ctx)
	if err != nil {
		return nil, fmt.Errorf("connecting to mongodb: %v", err)
	}

	return &Store{
		Client:                     client,
		UserRepository:             NewUserRepository(client),
	}, nil
}
```

Then it's just a matter of accessing the store and all the repositories in the store like this:

```go
store, err := NewStore(ctx, "localhost:27017")
...
store.UserRepository.FindUserById("5c7836b73a8de34c78fec399")
```

### Suggested Folder Structure
This is completely up to the developer, one option for projects that don't already have these package names is:
```bash
pkg
    - repositories
        - user.go
    - store
        - store.go
```